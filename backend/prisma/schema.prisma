generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  USER
  ADMIN
}

enum FriendshipStatus {
  PENDING
  ACCEPTED
  REJECTED
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  username  String   @unique
  password  String
  role      UserRole @default(USER)
  gender    String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  posts                Post[]            @relation("UserPosts")
  comments             Comment[]         @relation("UserComments")
  votes                Vote[]            @relation("UserVotes")
  communitiesOwned     Community[]       @relation("CommunityOwner")
  communityMemberships CommunityMember[] @relation("Memberships")

  // Friendships
  friendRequestsSent     Friendship[] @relation("FriendRequestsSent")
  friendRequestsReceived Friendship[] @relation("FriendRequestsReceived")

  // Chat
  conversations    ConversationParticipant[]
  sentMessages     Message[]                 @relation("MessageSender")
  receivedMessages Message[]                 @relation("MessageReceiver")

  @@map("users")
}

model Post {
  id          String     @id @default(cuid())
  title       String
  content     String
  authorId    String
  author      User       @relation("UserPosts", fields: [authorId], references: [id], onDelete: Cascade)
  tags        PostTag[]
  comments    Comment[]
  votes       Vote[]
  published   Boolean    @default(false)
  featured    Boolean    @default(false)
  viewCount   Int        @default(0)
  communityId Int?
  community   Community? @relation(fields: [communityId], references: [id], onDelete: Cascade)
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  @@map("posts")
}

model Comment {
  id        String   @id @default(cuid())
  content   String
  authorId  String
  author    User     @relation("UserComments", fields: [authorId], references: [id], onDelete: Cascade)
  postId    String
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  votes     Vote[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("comments")
}

model Tag {
  id        String    @id @default(cuid())
  name      String    @unique
  color     String?
  posts     PostTag[]
  createdAt DateTime  @default(now())

  @@map("tags")
}

model PostTag {
  postId String
  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)
  tagId  String
  tag    Tag    @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([postId, tagId])
  @@map("post_tags")
}

model Vote {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation("UserVotes", fields: [userId], references: [id], onDelete: Cascade)
  postId    String?
  post      Post?    @relation(fields: [postId], references: [id], onDelete: Cascade)
  commentId String?
  comment   Comment? @relation(fields: [commentId], references: [id], onDelete: Cascade)
  value     Int // 1 = upvote, -1 = downvote
  createdAt DateTime @default(now())

  @@unique([userId, postId])
  @@unique([userId, commentId])
  @@map("votes")
}

model Community {
  id          Int               @id @default(autoincrement())
  name        String
  slug        String            @unique
  description String?
  private     Boolean           @default(false)
  owner       User              @relation("CommunityOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId     String
  members     CommunityMember[]
  posts       Post[]
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
}

model CommunityMember {
  id          Int       @id @default(autoincrement())
  user        User      @relation("Memberships", fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  community   Community @relation(fields: [communityId], references: [id], onDelete: Cascade)
  communityId Int
  role        String    @default("MEMBER")
  createdAt   DateTime  @default(now())

  @@unique([userId, communityId])
}

model Friendship {
  id          String           @id @default(cuid())
  requester   User             @relation("FriendRequestsSent", fields: [requesterId], references: [id], onDelete: Cascade)
  requesterId String
  receiver    User             @relation("FriendRequestsReceived", fields: [receiverId], references: [id], onDelete: Cascade)
  receiverId  String
  status      FriendshipStatus @default(PENDING)
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  @@unique([requesterId, receiverId])
}

model Conversation {
  id           String                    @id @default(cuid())
  name         String?
  isGroup      Boolean                   @default(false)
  participants ConversationParticipant[]
  messages     Message[]
  createdAt    DateTime                  @default(now())
  updatedAt    DateTime                  @updatedAt

  @@map("conversations")
}

model ConversationParticipant {
  id             String       @id @default(cuid())
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  conversationId String
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId         String
  joinedAt       DateTime     @default(now())

  @@unique([userId, conversationId])
  @@map("conversation_participants")
}

model Message {
  id             String       @id @default(cuid())
  content        String
  sender         User         @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)
  senderId       String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  conversationId String
  receiver       User?        @relation("MessageReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  receiverId     String?
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  readAt         DateTime?

  @@map("messages")
}
